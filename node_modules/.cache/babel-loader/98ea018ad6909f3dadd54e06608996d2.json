{"ast":null,"code":"const squareLighter = 'rgb(212,198,159)';\nconst squareDarker = 'rgb(142,108,80)';\nconst pieceDarker = 'rgb(82,57,47)';\nconst pieceLighter = 'rgb(230,183,79)';\n\nfunction handleAllowedLighter(square) {\n  const squareIndex = getIndex(square);\n  const row = squareIndex.row - 1;\n  const sq = squareIndex.index;\n\n  if (squareIndex.index === 9) {\n    if (tabu[row][sq - 1].piece === null) {\n      return {\n        left: true,\n        right: false\n      };\n    } else {\n      return {\n        left: false,\n        right: false\n      };\n    }\n  }\n\n  if (squareIndex.index === 0) {\n    if (tabu[row][sq + 1].piece === null) {\n      return {\n        left: false,\n        right: true\n      };\n    } else {\n      return {\n        left: false,\n        right: false\n      };\n    }\n  }\n\n  let response = {\n    right: false,\n    left: false\n  };\n\n  if (tabu[row][sq - 1].piece === null) {\n    response.left = true;\n  }\n\n  if (tabu[row][sq + 1].piece === null) {\n    response.right = true;\n  }\n\n  return response;\n}\n\nfunction handleAllowedDarken(square) {\n  const squareIndex = getIndex(square);\n  const row = squareIndex.row + 1;\n  const sq = squareIndex.index;\n\n  if (sq === 9) {\n    if (tabu[row][sq - 1].piece === null) {\n      return {\n        left: false,\n        right: true\n      };\n    } else {\n      return {\n        left: false,\n        right: false\n      };\n    }\n  }\n\n  if (sq === 0) {\n    if (tabu[row][sq + 1].piece === null) {\n      return {\n        left: true,\n        right: false\n      };\n    } else {\n      return {\n        left: false,\n        right: false\n      };\n    }\n  }\n\n  let response = {\n    right: false,\n    left: false\n  };\n\n  if (tabu[row][sq - 1].piece === null) {\n    response.right = true;\n  }\n\n  if (tabu[row][sq + 1].piece === null) {\n    response.left = true;\n  }\n\n  return response;\n}\n\nexport function handleBorder() {\n  const result = tabu.map(row => {\n    return row.map(sq => {\n      if (sq && sq.id && sq.piece) {\n        if (sq.piece === pieceDarker) {\n          return { ...sq,\n            allowed: handleAllowedDarken(sq)\n          };\n        } else {\n          return { ...sq,\n            allowed: handleAllowedLighter(sq)\n          };\n        }\n      }\n\n      return sq;\n    });\n  });\n  return result;\n}\n\nfunction getIndex(square) {\n  let indexSquare = null;\n  tabu.forEach(row => row.forEach(sq => {\n    if (sq && sq.id && sq.id === square.id) {\n      indexSquare = {\n        row: tabu.indexOf(row),\n        index: row.indexOf(sq),\n        color: sq.piece\n      };\n    }\n  }));\n  return indexSquare;\n}\n\nexport function showMovements(square) {\n  // Finding index square\n  let indexSquare = getIndex(square); // movements for black\n\n  if (indexSquare.color === pieceDarker) {\n    // se ele for 9 ele so move pra direita, se ele for 1 ele so move pra esquerda\n    const row = indexSquare.row + 1;\n    const sq = indexSquare.index; // if is on the edge\n\n    if (row > 9 || row < 0) {\n      return false;\n    } // move if index is 9\n\n\n    if (indexSquare.index === 9) {\n      return {\n        left: null,\n        right: { ...tabu[row][sq - 1],\n          row,\n          square: sq - 1\n        }\n      };\n    } // move if index is 1\n\n\n    if (indexSquare.index === 0) {\n      return {\n        left: { ...tabu[row][sq + 1],\n          row,\n          square: sq + 1\n        },\n        right: null\n      };\n    } // move on both sides\n\n\n    return {\n      right: { ...tabu[row][sq - 1],\n        row,\n        square: sq - 1\n      },\n      left: { ...tabu[row][sq + 1],\n        row,\n        square: sq + 1\n      }\n    };\n  } // movements for white\n  else {\n      // se ele for 9 ele so move pra direita, se ele for 1 ele so move pra esquerda\n      const row = indexSquare.row - 1;\n      const sq = indexSquare.index; // if is on the edge\n\n      if (row > 9 || row < 0) {\n        return false;\n      } // move if index is 9\n\n\n      if (indexSquare.index === 9) {\n        return {\n          left: { ...tabu[row][sq - 1],\n            row,\n            square: sq - 1\n          },\n          right: null\n        };\n      } // move if index is 1\n\n\n      if (indexSquare.index === 0) {\n        return {\n          left: null,\n          right: { ...tabu[row][sq + 1],\n            row,\n            square: sq + 1\n          }\n        };\n      } // move on both sides\n\n\n      return {\n        left: { ...tabu[row][sq - 1],\n          row,\n          square: sq - 1\n        },\n        right: { ...tabu[row][sq + 1],\n          row,\n          square: sq + 1\n        }\n      };\n    }\n}\nexport function handleMove(actualPiece, futurePiece) {\n  // checking if futurePiece is available\n  if (!futurePiece.available) {\n    return;\n  }\n\n  const indexActualPiece = getIndex(actualPiece);\n  const indexFuturePiece = getIndex(futurePiece); // removing actual piece\n\n  const pieceMoved = tabu[indexActualPiece.row][indexActualPiece.index].piece;\n  tabu[indexActualPiece.row][indexActualPiece.index].piece = null; // puting in the future square\n\n  tabu[indexFuturePiece.row][indexFuturePiece.index].piece = pieceMoved;\n}","map":{"version":3,"sources":["/Users/henriqueolivoantonio/Desktop/Projects/damas/src/logic/index.js"],"names":["squareLighter","squareDarker","pieceDarker","pieceLighter","handleAllowedLighter","square","squareIndex","getIndex","row","sq","index","tabu","piece","left","right","response","handleAllowedDarken","handleBorder","result","map","id","allowed","indexSquare","forEach","indexOf","color","showMovements","handleMove","actualPiece","futurePiece","available","indexActualPiece","indexFuturePiece","pieceMoved"],"mappings":"AAAA,MAAMA,aAAa,GAAG,kBAAtB;AACA,MAAMC,YAAY,GAAG,iBAArB;AAEA,MAAMC,WAAW,GAAG,eAApB;AACA,MAAMC,YAAY,GAAG,iBAArB;;AAEA,SAASC,oBAAT,CAA8BC,MAA9B,EAAsC;AACpC,QAAMC,WAAW,GAAGC,QAAQ,CAACF,MAAD,CAA5B;AACA,QAAMG,GAAG,GAAGF,WAAW,CAACE,GAAZ,GAAkB,CAA9B;AACA,QAAMC,EAAE,GAAGH,WAAW,CAACI,KAAvB;;AAEA,MAAIJ,WAAW,CAACI,KAAZ,KAAsB,CAA1B,EAA6B;AAC3B,QAAIC,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,EAAkBG,KAAlB,KAA4B,IAAhC,EAAsC;AACpC,aAAO;AACLC,QAAAA,IAAI,EAAE,IADD;AAELC,QAAAA,KAAK,EAAE;AAFF,OAAP;AAID,KALD,MAKO;AACL,aAAO;AACLD,QAAAA,IAAI,EAAE,KADD;AAELC,QAAAA,KAAK,EAAE;AAFF,OAAP;AAID;AACF;;AAED,MAAIR,WAAW,CAACI,KAAZ,KAAsB,CAA1B,EAA6B;AAC3B,QAAIC,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,EAAkBG,KAAlB,KAA4B,IAAhC,EAAsC;AACpC,aAAO;AACLC,QAAAA,IAAI,EAAE,KADD;AAELC,QAAAA,KAAK,EAAE;AAFF,OAAP;AAID,KALD,MAKO;AACL,aAAO;AACLD,QAAAA,IAAI,EAAE,KADD;AAELC,QAAAA,KAAK,EAAE;AAFF,OAAP;AAID;AACF;;AAED,MAAIC,QAAQ,GAAG;AAAED,IAAAA,KAAK,EAAE,KAAT;AAAgBD,IAAAA,IAAI,EAAE;AAAtB,GAAf;;AACA,MAAIF,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,EAAkBG,KAAlB,KAA4B,IAAhC,EAAsC;AACpCG,IAAAA,QAAQ,CAACF,IAAT,GAAgB,IAAhB;AACD;;AACD,MAAIF,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,EAAkBG,KAAlB,KAA4B,IAAhC,EAAsC;AACpCG,IAAAA,QAAQ,CAACD,KAAT,GAAiB,IAAjB;AACD;;AACD,SAAOC,QAAP;AACD;;AAED,SAASC,mBAAT,CAA6BX,MAA7B,EAAqC;AACnC,QAAMC,WAAW,GAAGC,QAAQ,CAACF,MAAD,CAA5B;AACA,QAAMG,GAAG,GAAGF,WAAW,CAACE,GAAZ,GAAkB,CAA9B;AACA,QAAMC,EAAE,GAAGH,WAAW,CAACI,KAAvB;;AAEA,MAAID,EAAE,KAAK,CAAX,EAAc;AACZ,QAAIE,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,EAAkBG,KAAlB,KAA4B,IAAhC,EAAsC;AACpC,aAAO;AACLC,QAAAA,IAAI,EAAE,KADD;AAELC,QAAAA,KAAK,EAAE;AAFF,OAAP;AAID,KALD,MAKO;AACL,aAAO;AACLD,QAAAA,IAAI,EAAE,KADD;AAELC,QAAAA,KAAK,EAAE;AAFF,OAAP;AAID;AACF;;AAED,MAAIL,EAAE,KAAK,CAAX,EAAc;AACZ,QAAIE,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,EAAkBG,KAAlB,KAA4B,IAAhC,EAAsC;AACpC,aAAO;AACLC,QAAAA,IAAI,EAAE,IADD;AAELC,QAAAA,KAAK,EAAE;AAFF,OAAP;AAID,KALD,MAKO;AACL,aAAO;AACLD,QAAAA,IAAI,EAAE,KADD;AAELC,QAAAA,KAAK,EAAE;AAFF,OAAP;AAID;AACF;;AAED,MAAIC,QAAQ,GAAG;AAAED,IAAAA,KAAK,EAAE,KAAT;AAAgBD,IAAAA,IAAI,EAAE;AAAtB,GAAf;;AACA,MAAIF,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,EAAkBG,KAAlB,KAA4B,IAAhC,EAAsC;AACpCG,IAAAA,QAAQ,CAACD,KAAT,GAAiB,IAAjB;AACD;;AACD,MAAIH,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,EAAkBG,KAAlB,KAA4B,IAAhC,EAAsC;AACpCG,IAAAA,QAAQ,CAACF,IAAT,GAAgB,IAAhB;AACD;;AACD,SAAOE,QAAP;AACD;;AAED,OAAO,SAASE,YAAT,GAAwB;AAC7B,QAAMC,MAAM,GAAGP,IAAI,CAACQ,GAAL,CAAUX,GAAD,IAAS;AAC/B,WAAOA,GAAG,CAACW,GAAJ,CAASV,EAAD,IAAQ;AACrB,UAAIA,EAAE,IAAIA,EAAE,CAACW,EAAT,IAAeX,EAAE,CAACG,KAAtB,EAA6B;AAC3B,YAAIH,EAAE,CAACG,KAAH,KAAaV,WAAjB,EAA8B;AAC5B,iBAAO,EAAE,GAAGO,EAAL;AAASY,YAAAA,OAAO,EAAEL,mBAAmB,CAACP,EAAD;AAArC,WAAP;AACD,SAFD,MAEO;AACL,iBAAO,EAAE,GAAGA,EAAL;AAASY,YAAAA,OAAO,EAAEjB,oBAAoB,CAACK,EAAD;AAAtC,WAAP;AACD;AACF;;AACD,aAAOA,EAAP;AACD,KATM,CAAP;AAUD,GAXc,CAAf;AAYA,SAAOS,MAAP;AACD;;AAED,SAASX,QAAT,CAAkBF,MAAlB,EAA0B;AACxB,MAAIiB,WAAW,GAAG,IAAlB;AAEAX,EAAAA,IAAI,CAACY,OAAL,CAAcf,GAAD,IACXA,GAAG,CAACe,OAAJ,CAAad,EAAD,IAAQ;AAClB,QAAIA,EAAE,IAAIA,EAAE,CAACW,EAAT,IAAeX,EAAE,CAACW,EAAH,KAAUf,MAAM,CAACe,EAApC,EAAwC;AACtCE,MAAAA,WAAW,GAAG;AACZd,QAAAA,GAAG,EAAEG,IAAI,CAACa,OAAL,CAAahB,GAAb,CADO;AAEZE,QAAAA,KAAK,EAAEF,GAAG,CAACgB,OAAJ,CAAYf,EAAZ,CAFK;AAGZgB,QAAAA,KAAK,EAAEhB,EAAE,CAACG;AAHE,OAAd;AAKD;AACF,GARD,CADF;AAYA,SAAOU,WAAP;AACD;;AAED,OAAO,SAASI,aAAT,CAAuBrB,MAAvB,EAA+B;AACpC;AACA,MAAIiB,WAAW,GAAGf,QAAQ,CAACF,MAAD,CAA1B,CAFoC,CAIpC;;AAEA,MAAIiB,WAAW,CAACG,KAAZ,KAAsBvB,WAA1B,EAAuC;AACrC;AACA,UAAMM,GAAG,GAAGc,WAAW,CAACd,GAAZ,GAAkB,CAA9B;AACA,UAAMC,EAAE,GAAGa,WAAW,CAACZ,KAAvB,CAHqC,CAKrC;;AACA,QAAIF,GAAG,GAAG,CAAN,IAAWA,GAAG,GAAG,CAArB,EAAwB;AACtB,aAAO,KAAP;AACD,KARoC,CAUrC;;;AACA,QAAIc,WAAW,CAACZ,KAAZ,KAAsB,CAA1B,EAA6B;AAC3B,aAAO;AACLG,QAAAA,IAAI,EAAE,IADD;AAELC,QAAAA,KAAK,EAAE,EAAE,GAAGH,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,CAAL;AAAwBD,UAAAA,GAAxB;AAA6BH,UAAAA,MAAM,EAAEI,EAAE,GAAG;AAA1C;AAFF,OAAP;AAID,KAhBoC,CAiBrC;;;AACA,QAAIa,WAAW,CAACZ,KAAZ,KAAsB,CAA1B,EAA6B;AAC3B,aAAO;AACLG,QAAAA,IAAI,EAAE,EAAE,GAAGF,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,CAAL;AAAwBD,UAAAA,GAAxB;AAA6BH,UAAAA,MAAM,EAAEI,EAAE,GAAG;AAA1C,SADD;AAELK,QAAAA,KAAK,EAAE;AAFF,OAAP;AAID,KAvBoC,CAyBrC;;;AACA,WAAO;AACLA,MAAAA,KAAK,EAAE,EAAE,GAAGH,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,CAAL;AAAwBD,QAAAA,GAAxB;AAA6BH,QAAAA,MAAM,EAAEI,EAAE,GAAG;AAA1C,OADF;AAELI,MAAAA,IAAI,EAAE,EAAE,GAAGF,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,CAAL;AAAwBD,QAAAA,GAAxB;AAA6BH,QAAAA,MAAM,EAAEI,EAAE,GAAG;AAA1C;AAFD,KAAP;AAID,GA9BD,CAgCA;AAhCA,OAiCK;AACH;AACA,YAAMD,GAAG,GAAGc,WAAW,CAACd,GAAZ,GAAkB,CAA9B;AACA,YAAMC,EAAE,GAAGa,WAAW,CAACZ,KAAvB,CAHG,CAKH;;AACA,UAAIF,GAAG,GAAG,CAAN,IAAWA,GAAG,GAAG,CAArB,EAAwB;AACtB,eAAO,KAAP;AACD,OARE,CAUH;;;AACA,UAAIc,WAAW,CAACZ,KAAZ,KAAsB,CAA1B,EAA6B;AAC3B,eAAO;AACLG,UAAAA,IAAI,EAAE,EAAE,GAAGF,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,CAAL;AAAwBD,YAAAA,GAAxB;AAA6BH,YAAAA,MAAM,EAAEI,EAAE,GAAG;AAA1C,WADD;AAELK,UAAAA,KAAK,EAAE;AAFF,SAAP;AAID,OAhBE,CAiBH;;;AACA,UAAIQ,WAAW,CAACZ,KAAZ,KAAsB,CAA1B,EAA6B;AAC3B,eAAO;AACLG,UAAAA,IAAI,EAAE,IADD;AAELC,UAAAA,KAAK,EAAE,EAAE,GAAGH,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,CAAL;AAAwBD,YAAAA,GAAxB;AAA6BH,YAAAA,MAAM,EAAEI,EAAE,GAAG;AAA1C;AAFF,SAAP;AAID,OAvBE,CAyBH;;;AACA,aAAO;AACLI,QAAAA,IAAI,EAAE,EAAE,GAAGF,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,CAAL;AAAwBD,UAAAA,GAAxB;AAA6BH,UAAAA,MAAM,EAAEI,EAAE,GAAG;AAA1C,SADD;AAELK,QAAAA,KAAK,EAAE,EAAE,GAAGH,IAAI,CAACH,GAAD,CAAJ,CAAUC,EAAE,GAAG,CAAf,CAAL;AAAwBD,UAAAA,GAAxB;AAA6BH,UAAAA,MAAM,EAAEI,EAAE,GAAG;AAA1C;AAFF,OAAP;AAID;AACF;AAED,OAAO,SAASkB,UAAT,CAAoBC,WAApB,EAAiCC,WAAjC,EAA8C;AACnD;AACA,MAAI,CAACA,WAAW,CAACC,SAAjB,EAA4B;AAC1B;AACD;;AAED,QAAMC,gBAAgB,GAAGxB,QAAQ,CAACqB,WAAD,CAAjC;AACA,QAAMI,gBAAgB,GAAGzB,QAAQ,CAACsB,WAAD,CAAjC,CAPmD,CASnD;;AACA,QAAMI,UAAU,GAAGtB,IAAI,CAACoB,gBAAgB,CAACvB,GAAlB,CAAJ,CAA2BuB,gBAAgB,CAACrB,KAA5C,EAAmDE,KAAtE;AAEAD,EAAAA,IAAI,CAACoB,gBAAgB,CAACvB,GAAlB,CAAJ,CAA2BuB,gBAAgB,CAACrB,KAA5C,EAAmDE,KAAnD,GAA2D,IAA3D,CAZmD,CAcnD;;AACAD,EAAAA,IAAI,CAACqB,gBAAgB,CAACxB,GAAlB,CAAJ,CAA2BwB,gBAAgB,CAACtB,KAA5C,EAAmDE,KAAnD,GAA2DqB,UAA3D;AACD","sourcesContent":["const squareLighter = 'rgb(212,198,159)';\nconst squareDarker = 'rgb(142,108,80)';\n\nconst pieceDarker = 'rgb(82,57,47)';\nconst pieceLighter = 'rgb(230,183,79)';\n\nfunction handleAllowedLighter(square) {\n  const squareIndex = getIndex(square);\n  const row = squareIndex.row - 1;\n  const sq = squareIndex.index;\n\n  if (squareIndex.index === 9) {\n    if (tabu[row][sq - 1].piece === null) {\n      return {\n        left: true,\n        right: false,\n      };\n    } else {\n      return {\n        left: false,\n        right: false,\n      };\n    }\n  }\n\n  if (squareIndex.index === 0) {\n    if (tabu[row][sq + 1].piece === null) {\n      return {\n        left: false,\n        right: true,\n      };\n    } else {\n      return {\n        left: false,\n        right: false,\n      };\n    }\n  }\n\n  let response = { right: false, left: false };\n  if (tabu[row][sq - 1].piece === null) {\n    response.left = true;\n  }\n  if (tabu[row][sq + 1].piece === null) {\n    response.right = true;\n  }\n  return response;\n}\n\nfunction handleAllowedDarken(square) {\n  const squareIndex = getIndex(square);\n  const row = squareIndex.row + 1;\n  const sq = squareIndex.index;\n\n  if (sq === 9) {\n    if (tabu[row][sq - 1].piece === null) {\n      return {\n        left: false,\n        right: true,\n      };\n    } else {\n      return {\n        left: false,\n        right: false,\n      };\n    }\n  }\n\n  if (sq === 0) {\n    if (tabu[row][sq + 1].piece === null) {\n      return {\n        left: true,\n        right: false,\n      };\n    } else {\n      return {\n        left: false,\n        right: false,\n      };\n    }\n  }\n\n  let response = { right: false, left: false };\n  if (tabu[row][sq - 1].piece === null) {\n    response.right = true;\n  }\n  if (tabu[row][sq + 1].piece === null) {\n    response.left = true;\n  }\n  return response;\n}\n\nexport function handleBorder() {\n  const result = tabu.map((row) => {\n    return row.map((sq) => {\n      if (sq && sq.id && sq.piece) {\n        if (sq.piece === pieceDarker) {\n          return { ...sq, allowed: handleAllowedDarken(sq) };\n        } else {\n          return { ...sq, allowed: handleAllowedLighter(sq) };\n        }\n      }\n      return sq;\n    });\n  });\n  return result;\n}\n\nfunction getIndex(square) {\n  let indexSquare = null;\n\n  tabu.forEach((row) =>\n    row.forEach((sq) => {\n      if (sq && sq.id && sq.id === square.id) {\n        indexSquare = {\n          row: tabu.indexOf(row),\n          index: row.indexOf(sq),\n          color: sq.piece,\n        };\n      }\n    })\n  );\n\n  return indexSquare;\n}\n\nexport function showMovements(square) {\n  // Finding index square\n  let indexSquare = getIndex(square);\n\n  // movements for black\n\n  if (indexSquare.color === pieceDarker) {\n    // se ele for 9 ele so move pra direita, se ele for 1 ele so move pra esquerda\n    const row = indexSquare.row + 1;\n    const sq = indexSquare.index;\n\n    // if is on the edge\n    if (row > 9 || row < 0) {\n      return false;\n    }\n\n    // move if index is 9\n    if (indexSquare.index === 9) {\n      return {\n        left: null,\n        right: { ...tabu[row][sq - 1], row, square: sq - 1 },\n      };\n    }\n    // move if index is 1\n    if (indexSquare.index === 0) {\n      return {\n        left: { ...tabu[row][sq + 1], row, square: sq + 1 },\n        right: null,\n      };\n    }\n\n    // move on both sides\n    return {\n      right: { ...tabu[row][sq - 1], row, square: sq - 1 },\n      left: { ...tabu[row][sq + 1], row, square: sq + 1 },\n    };\n  }\n\n  // movements for white\n  else {\n    // se ele for 9 ele so move pra direita, se ele for 1 ele so move pra esquerda\n    const row = indexSquare.row - 1;\n    const sq = indexSquare.index;\n\n    // if is on the edge\n    if (row > 9 || row < 0) {\n      return false;\n    }\n\n    // move if index is 9\n    if (indexSquare.index === 9) {\n      return {\n        left: { ...tabu[row][sq - 1], row, square: sq - 1 },\n        right: null,\n      };\n    }\n    // move if index is 1\n    if (indexSquare.index === 0) {\n      return {\n        left: null,\n        right: { ...tabu[row][sq + 1], row, square: sq + 1 },\n      };\n    }\n\n    // move on both sides\n    return {\n      left: { ...tabu[row][sq - 1], row, square: sq - 1 },\n      right: { ...tabu[row][sq + 1], row, square: sq + 1 },\n    };\n  }\n}\n\nexport function handleMove(actualPiece, futurePiece) {\n  // checking if futurePiece is available\n  if (!futurePiece.available) {\n    return;\n  }\n\n  const indexActualPiece = getIndex(actualPiece);\n  const indexFuturePiece = getIndex(futurePiece);\n\n  // removing actual piece\n  const pieceMoved = tabu[indexActualPiece.row][indexActualPiece.index].piece;\n\n  tabu[indexActualPiece.row][indexActualPiece.index].piece = null;\n\n  // puting in the future square\n  tabu[indexFuturePiece.row][indexFuturePiece.index].piece = pieceMoved;\n}\n"]},"metadata":{},"sourceType":"module"}