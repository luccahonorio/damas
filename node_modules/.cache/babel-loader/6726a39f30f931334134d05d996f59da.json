{"ast":null,"code":"import { pieceDarker, squareColorDarker, squareSelected, checkEatingDark, checkEatingLight } from './index';\nconst eatNormalPiece = 1;\nconst eatQueenPiece = 1.5;\nconst movePiece = 0; // const diePiece = -1;\n// const dieQueenPiece = -1.5;\n// voce pode comer uma peça?\n// voce vai morrer?\n// se não vai andar normal\n// array [{id: 1, soma: 0}, {id: 2, soma: 1.5}]\n\nfunction getSquareInfo({\n  board,\n  square\n}) {\n  let indexSquare = null;\n  board.forEach(row => row.forEach(sq => {\n    if (sq && sq.id && sq.id === square.id) {\n      indexSquare = {\n        row: board.indexOf(row),\n        index: row.indexOf(sq),\n        piece: sq.piece,\n        id: sq.id\n      };\n    }\n  }));\n  return indexSquare;\n}\n\nfunction copyBoard({\n  board\n}) {\n  const newBoard = JSON.parse(JSON.stringify(board)).map(row => {\n    return row.map(sq => {\n      if (sq.color === squareSelected) {\n        sq.color = squareColorDarker;\n      }\n\n      return sq;\n    });\n  });\n  return newBoard;\n} // false, object, array\n\n\nfunction showMovementLightQueen({\n  board,\n  squareInfo\n}) {\n  // se ele tiver na posicao 0 ele nao anda mais e vira rainha\n  // se for 9 só pode mover pra esquerda\n  if (squareInfo.row === 0) {\n    return false;\n  }\n\n  if (squareInfo.index === 9) {\n    const left = board[squareInfo.row - 1][squareInfo.index - 1];\n\n    if (left && left.piece && left.piece.color === pieceDarker) {\n      return false;\n    }\n\n    if (left && left.piece && left.piece.color !== pieceDarker) {\n      if (checkEatingLight({\n        board,\n        square: left,\n        direction: 'left'\n      })) {\n        const newBoard = copyBoard({\n          board\n        });\n        const nextLeft = newBoard[squareInfo.row - 2][squareInfo.index - 2];\n        return {\n          next: nextLeft,\n          direction: 'left'\n        };\n      } else {\n        return false;\n      }\n    }\n\n    return left;\n  } // se for 0 só pode mover pra direita\n\n\n  if (squareInfo.index === 0) {\n    const right = board[squareInfo.row - 1][squareInfo.index + 1];\n\n    if (right && right.piece && right.piece.color === pieceDarker) {\n      return false;\n    }\n\n    if (right && right.piece && right.piece.color !== pieceDarker) {\n      if (checkEatingLight({\n        board,\n        square: right,\n        direction: 'right'\n      })) {\n        const newBoard = copyBoard({\n          board\n        });\n        const nextRight = newBoard[squareInfo.row - 2][squareInfo.index + 2];\n        return {\n          next: nextRight,\n          direction: 'right'\n        };\n      } else {\n        return false;\n      }\n    }\n\n    return right;\n  } // pode mover para os dois lados\n\n\n  const verify = {\n    left: true,\n    right: true\n  }; // left\n\n  const left = board[squareInfo.row - 1][squareInfo.index - 1];\n\n  if (left && left.piece && left.piece.color === pieceDarker) {\n    verify.left = false;\n  }\n\n  if (left && left.piece && left.piece.color !== pieceDarker) {\n    if (checkEatingLight({\n      board,\n      square: left,\n      direction: 'left'\n    })) {\n      const newBoard = copyBoard({\n        board\n      });\n      const nextLeft = newBoard[squareInfo.row - 2][squareInfo.index - 2];\n      return {\n        next: nextLeft,\n        direction: 'left'\n      };\n    } else {\n      verify.left = false;\n    }\n  } // right\n\n\n  const right = board[squareInfo.row - 1][squareInfo.index + 1];\n\n  if (right && right.piece && right.piece.color === pieceDarker) {\n    verify.right = false;\n  }\n\n  if (right && right.piece && right.piece.color !== pieceDarker) {\n    if (checkEatingLight({\n      board,\n      square: right,\n      direction: 'right'\n    })) {\n      const newBoard = copyBoard({\n        board\n      });\n      const nextRight = newBoard[squareInfo.row - 2][squareInfo.index + 2];\n      return {\n        next: nextRight,\n        direction: 'right'\n      };\n    } else {\n      verify.right = false;\n    }\n  }\n\n  let result = [];\n\n  if (verify.right) {\n    result = [right];\n  }\n\n  if (verify.left) {\n    result = [...result, left];\n  }\n\n  return result;\n} // ele pode retornar ou false ou o objeto\n\n\nfunction showMovementDark({\n  board,\n  squareInfo\n}) {\n  // se ele tiver na posicao 0 ele nao anda mais e vira rainha\n  // se for 9 só pode mover pra esquerda\n  if (squareInfo.row === 9) {\n    return false;\n  }\n\n  if (squareInfo.index === 9) {\n    const right = board[squareInfo.row + 1][squareInfo.index - 1];\n\n    if (right && right.piece && right.piece.color === pieceDarker) {\n      return false;\n    }\n\n    if (right && right.piece && right.piece.color !== pieceDarker) {\n      if (checkEatingDark({\n        board,\n        square: right,\n        direction: 'right'\n      })) {\n        const newBoard = copyBoard({\n          board\n        });\n        const nextRight = newBoard[squareInfo.row + 2][squareInfo.index - 2];\n        return {\n          next: nextRight,\n          direction: 'right'\n        };\n      } else {\n        return false;\n      }\n    }\n\n    return right;\n  } // se for 0 só pode mover pra direita\n\n\n  if (squareInfo.index === 0) {\n    const left = board[squareInfo.row + 1][squareInfo.index + 1];\n\n    if (left && left.piece && left.piece.color === pieceDarker) {\n      return false;\n    }\n\n    if (left && left.piece && left.piece.color !== pieceDarker) {\n      if (checkEatingDark({\n        board,\n        square: left,\n        direction: 'left'\n      })) {\n        const newBoard = copyBoard({\n          board\n        });\n        const nextleft = newBoard[squareInfo.row + 2][squareInfo.index + 2];\n        return {\n          next: nextleft,\n          direction: 'left'\n        };\n      } else {\n        return false;\n      }\n    }\n\n    return left;\n  } // pode mover para os dois lados\n\n\n  const verify = {\n    left: true,\n    right: true\n  }; // left\n\n  const right = board[squareInfo.row + 1][squareInfo.index - 1];\n\n  if (right && right.piece && right.piece.color === pieceDarker) {\n    verify.right = false;\n  }\n\n  if (right && right.piece && right.piece.color !== pieceDarker) {\n    if (checkEatingDark({\n      board,\n      square: right,\n      direction: 'right'\n    })) {\n      const newBoard = copyBoard({\n        board\n      });\n      const nextright = newBoard[squareInfo.row + 2][squareInfo.index - 2];\n      return {\n        next: nextright,\n        direction: 'right'\n      };\n    } else {\n      verify.right = false;\n    }\n  } // right\n\n\n  const left = board[squareInfo.row + 1][squareInfo.index + 1];\n\n  if (left.piece && left.piece.color === pieceDarker) {\n    verify.left = false;\n  }\n\n  if (left.piece && left.piece.color !== pieceDarker) {\n    if (checkEatingDark({\n      board,\n      square: left,\n      direction: 'left'\n    })) {\n      const newBoard = copyBoard({\n        board\n      });\n      const nextRight = newBoard[squareInfo.row + 2][squareInfo.index + 2];\n      return {\n        next: nextRight,\n        direction: 'left'\n      };\n    } else {\n      verify.left = false;\n    }\n  }\n\n  let result = [];\n\n  if (verify.left) {\n    result = [left];\n  }\n\n  if (verify.right) {\n    result = [...result, right];\n  }\n\n  if (result.length === 0) {\n    return false;\n  }\n\n  return result;\n}\n\nfunction countMovementValue({\n  board,\n  movements,\n  square\n}) {\n  let sum = movePiece; // voce pode comer? FEITO\n  // se nao ande normal\n  // Se é um array já quer dizer que não pode mover\n\n  if (!Array.isArray(movements) && movements && movements.next && movements.direction) {\n    // cant eat\n    // check if is a queen\n    const pieceInfo = getSquareInfo({\n      board,\n      square: movements.next\n    });\n    const direction = movements.direction;\n    const row = pieceInfo.row - 1;\n    let index = null;\n\n    if (direction === 'right') {\n      index = pieceInfo.index + 1;\n    } else {\n      index = pieceInfo.index - 1;\n    }\n\n    if (board[row][index].piece.queen) {\n      // é rainha\n      sum += eatQueenPiece;\n    } else {\n      sum += eatNormalPiece;\n    }\n  }\n\n  return {\n    movements,\n    square,\n    sum\n  };\n}\n\nfunction checkBestOption({\n  board,\n  square\n}) {\n  const squareInfo = getSquareInfo({\n    board,\n    square\n  });\n\n  if (squareInfo && squareInfo.piece && squareInfo.queen) {\n    // object -> pode comer, false -> não pode comer nada, array -> pode andar na esquerda e na direita\n    let movements = showMovementLightQueen({\n      board,\n      squareInfo\n    });\n\n    if (!Array.isArray(movements)) {\n      return countMovementValue({\n        board,\n        movements,\n        square\n      });\n    }\n\n    const movementsDark = showMovementDark({\n      board,\n      squareInfo\n    });\n\n    if (!movementsDark) {\n      return countMovementValue({\n        board,\n        movements,\n        square\n      });\n    }\n\n    return countMovementValue({\n      board,\n      movements: movementsDark,\n      square\n    });\n  } else {\n    const movements = showMovementDark({\n      board,\n      squareInfo\n    });\n    if (!movements) return;\n    return countMovementValue({\n      board,\n      movements,\n      square\n    });\n  }\n} // {movements: {}|[2], square, sum}\n\n\nfunction checkBestSum({\n  results\n}) {\n  let sum = -10;\n  let bestSquare = null;\n  results.forEach(result => {\n    if (result.sum > sum) {\n      bestSquare = result;\n      sum = result.sum;\n    }\n  }); // se ele tem um next\n\n  if (bestSquare && bestSquare.movements && bestSquare.movements.next) {\n    return {\n      selected: bestSquare.square,\n      square: bestSquare.movements.next,\n      sum: bestSquare.sum\n    };\n  } // se ele tiver duas opcoes retorna sempre o da esquerda\n\n\n  if (Array.isArray(bestSquare.movements)) {\n    return {\n      selected: bestSquare.square,\n      square: bestSquare.movements[0],\n      sum: bestSquare.sum\n    };\n  }\n\n  return {\n    selected: bestSquare.square,\n    square: bestSquare.movements,\n    sum: bestSquare.sum\n  };\n}\n\nexport function handleAlphaBeta({\n  board\n}) {\n  const results = [];\n  board.forEach(row => row.forEach(square => {\n    if (square && square.id && square.piece && square.piece.color && square.piece.color === pieceDarker) {\n      const bestOption = checkBestOption({\n        board,\n        square\n      });\n\n      if (bestOption) {\n        results.push(bestOption);\n      }\n    }\n  }));\n  return checkBestSum({\n    results\n  });\n}","map":{"version":3,"sources":["/Users/henriqueolivoantonio/Desktop/Projects/damas/src/logic/ia.js"],"names":["pieceDarker","squareColorDarker","squareSelected","checkEatingDark","checkEatingLight","eatNormalPiece","eatQueenPiece","movePiece","getSquareInfo","board","square","indexSquare","forEach","row","sq","id","indexOf","index","piece","copyBoard","newBoard","JSON","parse","stringify","map","color","showMovementLightQueen","squareInfo","left","direction","nextLeft","next","right","nextRight","verify","result","showMovementDark","nextleft","nextright","length","countMovementValue","movements","sum","Array","isArray","pieceInfo","queen","checkBestOption","movementsDark","checkBestSum","results","bestSquare","selected","handleAlphaBeta","bestOption","push"],"mappings":"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","sourcesContent":["import {\n  pieceDarker,\n  squareColorDarker,\n  squareSelected,\n  checkEatingDark,\n  checkEatingLight,\n} from './index';\nconst eatNormalPiece = 1;\nconst eatQueenPiece = 1.5;\nconst movePiece = 0;\n// const diePiece = -1;\n// const dieQueenPiece = -1.5;\n\n// voce pode comer uma peça?\n// voce vai morrer?\n// se não vai andar normal\n\n// array [{id: 1, soma: 0}, {id: 2, soma: 1.5}]\n\nfunction getSquareInfo({ board, square }) {\n  let indexSquare = null;\n\n  board.forEach((row) =>\n    row.forEach((sq) => {\n      if (sq && sq.id && sq.id === square.id) {\n        indexSquare = {\n          row: board.indexOf(row),\n          index: row.indexOf(sq),\n          piece: sq.piece,\n          id: sq.id,\n        };\n      }\n    })\n  );\n\n  return indexSquare;\n}\n\nfunction copyBoard({ board }) {\n  const newBoard = JSON.parse(JSON.stringify(board)).map((row) => {\n    return row.map((sq) => {\n      if (sq.color === squareSelected) {\n        sq.color = squareColorDarker;\n      }\n      return sq;\n    });\n  });\n  return newBoard;\n}\n\n// false, object, array\nfunction showMovementLightQueen({ board, squareInfo }) {\n  // se ele tiver na posicao 0 ele nao anda mais e vira rainha\n  // se for 9 só pode mover pra esquerda\n  if (squareInfo.row === 0) {\n    return false;\n  }\n\n  if (squareInfo.index === 9) {\n    const left = board[squareInfo.row - 1][squareInfo.index - 1];\n    if (left && left.piece && left.piece.color === pieceDarker) {\n      return false;\n    }\n    if (left && left.piece && left.piece.color !== pieceDarker) {\n      if (checkEatingLight({ board, square: left, direction: 'left' })) {\n        const newBoard = copyBoard({ board });\n        const nextLeft = newBoard[squareInfo.row - 2][squareInfo.index - 2];\n        return { next: nextLeft, direction: 'left' };\n      } else {\n        return false;\n      }\n    }\n\n    return left;\n  }\n  // se for 0 só pode mover pra direita\n  if (squareInfo.index === 0) {\n    const right = board[squareInfo.row - 1][squareInfo.index + 1];\n    if (right && right.piece && right.piece.color === pieceDarker) {\n      return false;\n    }\n    if (right && right.piece && right.piece.color !== pieceDarker) {\n      if (checkEatingLight({ board, square: right, direction: 'right' })) {\n        const newBoard = copyBoard({ board });\n        const nextRight = newBoard[squareInfo.row - 2][squareInfo.index + 2];\n        return { next: nextRight, direction: 'right' };\n      } else {\n        return false;\n      }\n    }\n\n    return right;\n  }\n  // pode mover para os dois lados\n  const verify = { left: true, right: true };\n\n  // left\n  const left = board[squareInfo.row - 1][squareInfo.index - 1];\n  if (left && left.piece && left.piece.color === pieceDarker) {\n    verify.left = false;\n  }\n  if (left && left.piece && left.piece.color !== pieceDarker) {\n    if (checkEatingLight({ board, square: left, direction: 'left' })) {\n      const newBoard = copyBoard({ board });\n      const nextLeft = newBoard[squareInfo.row - 2][squareInfo.index - 2];\n      return { next: nextLeft, direction: 'left' };\n    } else {\n      verify.left = false;\n    }\n  }\n\n  // right\n  const right = board[squareInfo.row - 1][squareInfo.index + 1];\n  if (right && right.piece && right.piece.color === pieceDarker) {\n    verify.right = false;\n  }\n  if (right && right.piece && right.piece.color !== pieceDarker) {\n    if (checkEatingLight({ board, square: right, direction: 'right' })) {\n      const newBoard = copyBoard({ board });\n      const nextRight = newBoard[squareInfo.row - 2][squareInfo.index + 2];\n      return { next: nextRight, direction: 'right' };\n    } else {\n      verify.right = false;\n    }\n  }\n\n  let result = [];\n  if (verify.right) {\n    result = [right];\n  }\n  if (verify.left) {\n    result = [...result, left];\n  }\n\n  return result;\n}\n\n// ele pode retornar ou false ou o objeto\nfunction showMovementDark({ board, squareInfo }) {\n  // se ele tiver na posicao 0 ele nao anda mais e vira rainha\n  // se for 9 só pode mover pra esquerda\n\n  if (squareInfo.row === 9) {\n    return false;\n  }\n\n  if (squareInfo.index === 9) {\n    const right = board[squareInfo.row + 1][squareInfo.index - 1];\n    if (right && right.piece && right.piece.color === pieceDarker) {\n      return false;\n    }\n    if (right && right.piece && right.piece.color !== pieceDarker) {\n      if (checkEatingDark({ board, square: right, direction: 'right' })) {\n        const newBoard = copyBoard({ board });\n        const nextRight = newBoard[squareInfo.row + 2][squareInfo.index - 2];\n        return { next: nextRight, direction: 'right' };\n      } else {\n        return false;\n      }\n    }\n\n    return right;\n  }\n  // se for 0 só pode mover pra direita\n  if (squareInfo.index === 0) {\n    const left = board[squareInfo.row + 1][squareInfo.index + 1];\n    if (left && left.piece && left.piece.color === pieceDarker) {\n      return false;\n    }\n    if (left && left.piece && left.piece.color !== pieceDarker) {\n      if (checkEatingDark({ board, square: left, direction: 'left' })) {\n        const newBoard = copyBoard({ board });\n        const nextleft = newBoard[squareInfo.row + 2][squareInfo.index + 2];\n        return { next: nextleft, direction: 'left' };\n      } else {\n        return false;\n      }\n    }\n\n    return left;\n  }\n  // pode mover para os dois lados\n  const verify = { left: true, right: true };\n\n  // left\n  const right = board[squareInfo.row + 1][squareInfo.index - 1];\n  if (right && right.piece && right.piece.color === pieceDarker) {\n    verify.right = false;\n  }\n  if (right && right.piece && right.piece.color !== pieceDarker) {\n    if (checkEatingDark({ board, square: right, direction: 'right' })) {\n      const newBoard = copyBoard({ board });\n      const nextright = newBoard[squareInfo.row + 2][squareInfo.index - 2];\n      return { next: nextright, direction: 'right' };\n    } else {\n      verify.right = false;\n    }\n  }\n\n  // right\n  const left = board[squareInfo.row + 1][squareInfo.index + 1];\n  if (left.piece && left.piece.color === pieceDarker) {\n    verify.left = false;\n  }\n  if (left.piece && left.piece.color !== pieceDarker) {\n    if (checkEatingDark({ board, square: left, direction: 'left' })) {\n      const newBoard = copyBoard({ board });\n      const nextRight = newBoard[squareInfo.row + 2][squareInfo.index + 2];\n      return { next: nextRight, direction: 'left' };\n    } else {\n      verify.left = false;\n    }\n  }\n\n  let result = [];\n  if (verify.left) {\n    result = [left];\n  }\n  if (verify.right) {\n    result = [...result, right];\n  }\n\n  if (result.length === 0) {\n    return false;\n  }\n  return result;\n}\n\nfunction countMovementValue({ board, movements, square }) {\n  let sum = movePiece;\n  // voce pode comer? FEITO\n  // se nao ande normal\n  // Se é um array já quer dizer que não pode mover\n  if (\n    !Array.isArray(movements) &&\n    movements &&\n    movements.next &&\n    movements.direction\n  ) {\n    // cant eat\n    // check if is a queen\n    const pieceInfo = getSquareInfo({ board, square: movements.next });\n    const direction = movements.direction;\n    const row = pieceInfo.row - 1;\n    let index = null;\n    if (direction === 'right') {\n      index = pieceInfo.index + 1;\n    } else {\n      index = pieceInfo.index - 1;\n    }\n    if (board[row][index].piece.queen) {\n      // é rainha\n      sum += eatQueenPiece;\n    } else {\n      sum += eatNormalPiece;\n    }\n  }\n\n  return { movements, square, sum };\n}\n\nfunction checkBestOption({ board, square }) {\n  const squareInfo = getSquareInfo({ board, square });\n  if (squareInfo && squareInfo.piece && squareInfo.queen) {\n    // object -> pode comer, false -> não pode comer nada, array -> pode andar na esquerda e na direita\n    let movements = showMovementLightQueen({ board, squareInfo });\n    if (!Array.isArray(movements)) {\n      return countMovementValue({ board, movements, square });\n    }\n    const movementsDark = showMovementDark({ board, squareInfo });\n    if (!movementsDark) {\n      return countMovementValue({ board, movements, square });\n    }\n    return countMovementValue({ board, movements: movementsDark, square });\n  } else {\n    const movements = showMovementDark({ board, squareInfo });\n    if (!movements) return;\n    return countMovementValue({ board, movements, square });\n  }\n}\n\n// {movements: {}|[2], square, sum}\nfunction checkBestSum({ results }) {\n  let sum = -10;\n  let bestSquare = null;\n  results.forEach((result) => {\n    if (result.sum > sum) {\n      bestSquare = result;\n      sum = result.sum;\n    }\n  });\n\n  // se ele tem um next\n  if (bestSquare && bestSquare.movements && bestSquare.movements.next) {\n    return {\n      selected: bestSquare.square,\n      square: bestSquare.movements.next,\n      sum: bestSquare.sum,\n    };\n  }\n  // se ele tiver duas opcoes retorna sempre o da esquerda\n  if (Array.isArray(bestSquare.movements)) {\n    return {\n      selected: bestSquare.square,\n      square: bestSquare.movements[0],\n      sum: bestSquare.sum,\n    };\n  }\n\n  return {\n    selected: bestSquare.square,\n    square: bestSquare.movements,\n    sum: bestSquare.sum,\n  };\n}\n\nexport function handleAlphaBeta({ board }) {\n  const results = [];\n  board.forEach((row) =>\n    row.forEach((square) => {\n      if (\n        square &&\n        square.id &&\n        square.piece &&\n        square.piece.color &&\n        square.piece.color === pieceDarker\n      ) {\n        const bestOption = checkBestOption({ board, square });\n        if (bestOption) {\n          results.push(bestOption);\n        }\n      }\n    })\n  );\n  return checkBestSum({ results });\n}\n"]},"metadata":{},"sourceType":"module"}